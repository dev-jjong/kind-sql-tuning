--3 인덱스 튜닝
--3.1 테이블 액세스 최소화
-- 핵심내용 : SQL 튜닝은 랜덤 I/O와의 전쟁이다.

/*
    3.1.1 테이블 랜덤 액세스
        [1] 인덱스 튜닝의 2가지 사실
            - 아무리 데이터가 많아도 인덱스를 사용하니까 데이터가 근방 조회된다는 사실
            - 대량 데이터를 조회할 때 인덱스를 사용하니 테이블 전체를 스캔할 때보다 훨씬 느리다는 사실
            
        [2] 인덱스 ROWID는 물리적주소? 논리적주소?
            - SQL이 참조하는 컬럼을 인덱스가 모두 포함하는 경우가 아니라면, 인덱스를 스캔한 후에 반드시 테이블을 액세스한다.
                (실행계획에 TABLE ACCESS BY INDEX ROWID 라고 표시된다)
            - 인덱스를 스캔하는 이유는 검색 조건을 만족하는 소량을 데이터를 인덱스에서 빨리 찾고 거기서 테이블 레코드를 찾아가기 위한
                주소값(ROWID)를 얻으려는 데 있다.
            - 인덱스 ROWID는 논리적 주소다. 디스크 상에서 테이블 레코드를 찾아가기 위한 위치 정보를 담는다.
            
        [3] 메인 메모리 DB와 비교
            - 메인 메모리 DB(MMDB)란? 
                데이터를 모두 메모리에 로드해 놓고 메모리를 통해서만 I/O를 수행하는 DB
            - 반면 오라클은 테이블 블록이 수시로 버퍼캐시에 밀려났다가 다시 캐핑되며, 그때마다 다른 공간에 캐싱되기 때문에 인덱스에서
                포인터로 직접 연결할 수 없는 구조이다.
            - 즉, 메모리 주소 정보(포인터)가 아닌 디스크 주소 정보(DBA)를 이용해 해시 알고리즘으로 버퍼 블록을 찾아간다
            
        [4] I/O매커니즘 복습
            - 인덱스로 테이블 블록을 액세스할 때는 리프 블록에서 읽은 ROWID를 분해해서 DBA 정보를 얻고, 테이블을 Full Scan 할 때는
                익스텐트 맵을 통해 읽을 블록들의 DBA 정보를 얻는다.
            - ROWID가 가리키는 테이블 블록을 버퍼캐시에서 먼저 찾아보고, 못 찾을 때만 디스크에서 블록을 읽는다.
                물론 버퍼캐피에 적재한 후에 읽는다.
            - 설령 모든 데이터가 캐싱돼 있더라도 테이블 레코드를 찾기 위해 매번 DBA해싱과 래치 획득 과정을 반복해야 한다.
                동시 액세스가 심할때는 캐시버퍼 체인 래치와 버퍼 Lock에 대한 경합까지 발생한다.
                즉, 인덱스 ROWID를 이용한 테이블 액세스는 생각보다 고비용 구조이다
            
        [5] 인덱스 ROWID는 우편주소
            - 디스크 DB가 사용하는 ROWID를 우편주소에, 메인 메모리 DB가 사용하는 포인터를 전화번호에 비유할 수 있다.
                전화통신은 물리적으로 연결된 통신망을 이용하므로 곧바로 상대방과 통화할 수 있다.
                반면, 우편번호는 봉투에 적힌 대로 우체부 아저씨가 일일이 찾아다니는 구조라고 생각하면 된다.
                

    3.1.2 인덱스 클러스터링 팩터 (CF)
        - 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도
        - 군집성 계수도 한다.
        - CF가 좋은 컬럼에 생성한 인덱스를 검색 효율이 좋다고 헀는데, 이는 테이블 액세스량에 비해 블록 I/O가 적게 발생함을 의미한다.
        - CF가 좋으면 버퍼 Pinning으로 인해 래치 획득과 해시 체인 스캔 과정을 생략하고 바로 테이블을 읽기 때문에 빠르다.
        - 버퍼 Pinning이란? 
            인덱스 ROWID로 테이블을 액세스할 때, 오라클은 래치 획득과 해시 체인 스캔 과정을 거쳐 어렵게 찾아간 테이블 블록에 대한 
            포인터(메모리 주소값)를 바로 해제하지 않고 일단 유지하는 것
        - CF가 안 좋은 인덱스를 사용하면 테이블을 액세스하는 횟수만큼 고스란히 블록 I/O가 발생한다.
        
    3.1.3 인덱스 손익분기점
        [1] 인덱스 손익분기점이란?
            - Index Range Scan에 의한 테이블 액세스가 Table Full Scan보다 느려지는 지점
            - 인덱스를 이용해 테이블을 액세스할 때는 전체 1,000만건 중 몇 건을 추출하느냐에 따라 성능이 크게 달라진다
        
        [2] 인덱스를 이용한 테이블 엑세스가 Table Full Scan 보다 더 느려지는 이유
            - Table Full Scan은 시퀀셜 액세스인 반면, 인덱스 ROWID를 이용한 테이블 액세스는 랜덤 액세스 방식이다
            - Table Full Scan은 Multiblock I/O인 반면, 인덱스 ROWID를 이용한 테이블 액세스는 Single Block I/O 방식이다
            
        [3] 온라인 프로그램 튜닝 vs 배치 프로그램 튜닝
            - 온라인 프로그램은 보통 소량 데이터를 읽고 갱신하므로 인덱스를 효과적으로 활용하는 것이 중요하다. (NL조인을 사용한다)
            - 대량 데이터를 읽고 갱신하는 배치(Batch) 프로그램은 항상 전체범위 처리 기준으로 튜닝해야한다. 즉, 처리대상 집합 중 일부를 빠르게 하는게 아니라
                전체를 빠르게 처리하는 것을 목표로 삼아야 한다 (Full Scan과 해시 조인이 유리하다)

*/




